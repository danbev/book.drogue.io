<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Untitled :: Drogue IoT</title>
    <meta name="generator" content="Antora 2.3.4">
    <link rel="stylesheet" href="../../_/css/site.css">
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-Z4BRXRBJJ1"></script>
    <script>function gtag(){dataLayer.push(arguments)};window.dataLayer=window.dataLayer||[];gtag('js',new Date());gtag('config','G-Z4BRXRBJJ1')</script>
    <script>var uiRootPath = '../../_'</script>
    <link rel="icon" href="../../_/img/favicon.svg" type="image/svg+xml">
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="../..">
        <img class="navbar-brand-image" src="../../_/img/logo.png" alt="Drogue IoT"/>
      </a>

      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <a class="navbar-item" href="https://blog.drogue.io" target="_blank">Blog</a>
        <a class="navbar-item" href="https://matrix.to/#/#drogue-iot:matrix.org" target="_blank">Chat</a>
        <a class="navbar-item" href="https://book.drogue.io">Documentation</a>
      </div>
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="drogue-device" data-version="dev">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <h3 class="title"><a href="index.html">Drogue Device</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="concepts.html">Concepts</a>
  </li>
  <li class="nav-item is-current-page" data-depth="1">
    <a class="nav-link" href="drivers.html">Drivers</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="examples.html">Examples</a>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">Drogue Device</span>
    <span class="version">dev</span>
  </div>
  <ul class="components">
    <li class="component">
      <a class="title" href="../../drogue-cloud/dev/index.html">Drogue Cloud</a>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../drogue-cloud/dev/index.html">dev</a>
        </li>
        <li class="version">
          <a href="../../drogue-cloud/0.5/index.html">0.5</a>
        </li>
        <li class="version">
          <a href="../../drogue-cloud/0.4/index.html">0.4</a>
        </li>
      </ul>
    </li>
    <li class="component is-current">
      <a class="title" href="index.html">Drogue Device</a>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="index.html">dev</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <a class="title" href="../../drogue-book/index.html">Drogue IoT</a>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../drogue-book/index.html">master</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <a class="title" href="../../drogue-workshops/index.html">Drogue IoT Workshops</a>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../drogue-workshops/index.html">master</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="../../drogue-book/index.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="index.html">Drogue Device</a></li>
    <li><a href="drivers.html">Drivers</a></li>
  </ul>
</nav>
  <div class="edit-this-page"><a href="https://github.com/drogue-iot/drogue-device/edit/main/docs/modules/ROOT/pages/drivers.adoc">Edit this Page</a></div>
  </div>
  <div class="content">
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<div class="sect1">
<h2 id="_writing_drogue_device_drivers"><a class="anchor" href="#_writing_drogue_device_drivers"></a>Writing drogue device drivers</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Drogue-device contains device drivers for different boards and sensors.  Drivers follow a common set
of patterns that makes it easier to write new drivers. Device drivers can be written in different
ways, but the common approach is to implement one or more of the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A trait that defines the API that drivers implement. This may already exist, either in
drogue-device or elsewhere. We encourage re-using existing traits where it makes sense. The traits
are located in <code>device/src/traits</code>.</p>
</li>
<li>
<p>A driver that implements an API, either using a HAL or hardware directly. Drivers are located in
<code>device/src/drivers/</code>.</p>
</li>
<li>
<p>An actor implementation for the driver. This is useful for peripherals that require shared access
by multiple parts of the system, as the actor will ensure its only serving one user at a time.
Actors are located in <code>device/src/actors</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Which of the above you decide to implement depends on the driver. A Led may not need an Actor,
because it is usually operated only by a single component, whereas it makes sense for a network
stack/driver that is used by multiple components. The nice properties of actors is that they compose
easily.</p>
</div>
<div class="paragraph">
<p>Actors does carry with them some overhead of extra code to spawn the actor and holding incoming
messages in a queue. Therefore, it sometimes makes sense using a layered approach for drivers: A
driver that can be used for the cases where you don&#8217;t need the shared access, and an Actor using
that driver where you need shared access.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_writing_an_async_trait"><a class="anchor" href="#_writing_an_async_trait"></a>Writing an async trait</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Drogue-device supports both sync and async APIs, and both have their uses. Sync traits are covered
by the Rust documentation.  Unfortunately, the support in Rust for writing async traits is limited,
but it is possible using features from Rust nightly.</p>
</div>
<div class="paragraph">
<p>An async trait can be specified by enabling a feature named generic associcated types (GAT):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-rust hljs" data-lang="rust">#![feature(generic_associated_types)]

pub trait Counter {
    type IncrementFuture&lt;'m&gt;: Future&lt;Output = u32&gt; where Self: 'm;
    fn increment&lt;'m&gt;(&amp;'m mut self) -&gt; Self::IncrementFuture&lt;'m&gt;;

    type AddFuture&lt;'m&gt;: Future&lt;Output = u32&gt; where Self: 'm;
    fn add&lt;'m&gt;(&amp;'m mut self, value: u32) -&gt; Self::AddFuture&lt;'m&gt;;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>An implementor of the above trait will be able to write async code with some boilerplate, and application code can rely on the trait.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_writing_an_async_driver"><a class="anchor" href="#_writing_an_async_driver"></a>Writing an async driver</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A driver is an implementation of the trait that applications use. With the trait defined in the previous section, lets take a look at what a driver would look like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-rust hljs" data-lang="rust">#![feature(type_alias_impl_trait)]
#![feature(generic_associated_types)]

pub struct MyCounter {
    value: u32,
}

impl Counter for MyCounter {
    type IncrementFuture&lt;'m&gt; = impl Future&lt;Output = u32&gt; + 'm;
    fn increment&lt;'m&gt;(&amp;'m mut self) -&gt; Self::IncrementFuture&lt;'m&gt; {
        async move {
            self.counter += 1;
        }
    }

    type AddFuture&lt;'m&gt; = impl Future&lt;Output = u32&gt; + 'm;
    fn add&lt;'m&gt;(&amp;'m mut self, value: u32) -&gt; Self::AddFuture&lt;'m&gt; {
        async move {
            self.counter += value;
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You&#8217;ll notice that we&#8217;ve used yet another nightly feature that allows specifying the
<code>IncrementFuture</code> associated type using the <code>impl Future&lt;&#8230;&#8203;&gt;</code> syntax.</p>
</div>
<div class="paragraph">
<p>At the expense of needing to define the associated type and a somewhat awkward return value, the
driver can write blocks of async code to implement the trait.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_writing_an_actor"><a class="anchor" href="#_writing_an_actor"></a>Writing an Actor</h2>
<div class="sectionbody">
<div class="paragraph">
<p>An actor must implement the <code>Actor</code> trait, which will allow it to be mounted into the drogue device
runtime. An actor providing an atomic counter using the above driver is shown below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-rust hljs" data-lang="rust">#![feature(type_alias_impl_trait)]
#![feature(generic_associated_types)]
pub struct AtomicCounter {
    counter: MyCounter
}

pub enum CounterMessage {
    Increment,
    Add(u32),
}

impl Actor for AtomicCounter {
    type Message&lt;'m&gt; = CounterMessage;
    type Response&lt;'m&gt; = u32;

    type OnStartFuture&lt;'m&gt; = impl Future&lt;Output = ()&gt; + 'm;
    fn on_start(mut self: Pin&lt;&amp;mut Self&gt;) -&gt; Self::OnStartFuture&lt;'_&gt; {
       async move {
       }
    }

    type OnMessageFuture&lt;'m&gt; = impl Future&lt;Output = u32&gt; + 'm;
    fn on_message&lt;'m&gt;(self: Pin&lt;&amp;'m mut Self&gt;, message: Self::Message&lt;'m&gt;) -&gt; Self::OnMessageFuture&lt;'m&gt; {
        async move {
            match message {
                CounterMessage::Increment =&gt; self.counter.increment().await,
                CounterMessage::Add(value) =&gt; self.counter.add(value).await,
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Although a very complex way to implement an atomic counter, it gives you an idea of how actors provide exclusive access to a resource.</p>
</div>
</div>
</div>
</article>
  </div>
</main>
</div>
<footer class="footer">
  <p>This page was built using the Antora default UI.</p>
  <p>The source code for this UI is licensed under the terms of the MPL-2.0 license.</p>
</footer>
<script src="../../_/js/site.js"></script>
<script async src="../../_/js/vendor/highlight.js"></script>
  </body>
</html>
